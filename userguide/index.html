<!DOCTYPE HTML>
<html>
<head>

  <!-- ************* Meta ************* -->
  <title>User Guide · N4JS Language and IDE</title>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  
  <!-- ************* OpenGraph ************-->
  <meta name="description" content="The N4JS language and its IDE enable high-quality JavaScript development for large Node.js projects.">
  
  <meta property="og:site_name" content="N4JS"/>
  <meta property="og:title" content="N4JS Language and IDE"/>
  <meta property="og:url" content="https://numberfour.github.io/n4js"/>
  <meta property="og:description" content="The N4JS language and its IDE enable high-quality JavaScript development for large Node.js projects."/>
  <meta property="og:image" content="../imgs/n4js.png">
  
  <!-- ************* Favicon ************-->
  <link rel="icon" href="../imgs/favicon.ico" />
  <link rel="icon" type="image/png" href="../imgs/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../imgs/favicon-16x16.png" sizes="16x16" />
  <!-- ************* Styles ************* -->
  <link type="text/css" rel="stylesheet" href="//fast.fonts.net/cssapi/20974f8a-0939-4574-aef9-681eda2faca8.css"/>
  <link rel="stylesheet" type="text/css" href="../styles/styles.min.c66c9067.css">


  <!-- ****************** Scripts ****************** -->
  <script type="text/javascript" src="../scripts/scripts-legacy.6f2064d5.js"></script>
</head>

<body>
  <header class="Grid">
    <div class="Cell Cell--4-12">
      <a href="../"><img src="../imgs/n4js-logo.png" alt="N4JS Language and IDE"></a>
    </div>

    <div class="Cell Cell--8-12">
      <nav>
         <a href="../#getting-started">Getting Started</a> ·
         <a href="../features">Features</a> ·
         <a href="../releases">Releases</a> ·
         <a href="../userguide" class="is-active">User-Guide</a> ·
         <a href="../faq">FAQ</a>
      </nav>
    </div>
  </header>


  <div class="Main">
    <nav class="Nav--top">
      <h2>Sections</h2>
      <ul>
        <li><a href="#GettingStarted">Getting Started</a></li>
        <li><a href="#Installation">Installation</a></li>
        <li><a href="#Overview">Overview</a></li>
        <li><a href="#DomainModel">The Domain Model</a></li>
        <li><a href="#Storage">The Storage Layer</a></li>
        <li><a href="#TaskManager">Creating a Task Manager</a></li>
        <li><a href="#Testing">Testing</a></li>
        <li><a href="#MongoDB">Storage Using MongoDB</a></li>
        <li><a href="#DI">Dependency Injection</a></li>
        <li><a href="#WebUI">Web UI Module</a></li>
        <li><a href="#ExportAsNPM">Export as npm</a></li>
        <li><a href="#RunWithNode">Run with Node.js</a></li>
      </ul>
    </nav>

    <article class="Article--noGrid">


      <h1>Write Type-Safe Node.js Modules with N4JS</h1>

      <h2 id="GettingStarted">Getting Started</h2>

      <h3>The flexibility of JavaScript with the type-safety of Java.</h3>

      <p>N4JS is a language and IDE designed for developers who need to build scalable projects whose code is modular, reusable and easily maintainable over time. N4JS bridges the strengths of ECMAScript (also known as JavaScript) and Java. The result is a typed JavaScript superset that is dynamic, flexible and type-safe.</p>

      <h3>Experience with JavaScript or Java?</h3>


      <p>Developers who are experienced with JavaScript can easily apply their knowledge in N4JS. As N4JS is a typed superset of ECMAScript, it is possible to use plain ECMAScript in N4JS. Most of the important features from ECMAScript 2015 are supported, such as <strong>modules</strong> with import and export, <strong>classes</strong>, <strong>iterables</strong> and <strong>destructuring</strong> of arrays and objects. Developers who have experience using Java will be familiar with features from Java 8 such as <strong>nominal typing</strong>, <strong>interfaces</strong> and <strong>generic classes and methods</strong>; even dependency injection and testing look similar.</p>


      <h3>Development Environment</h3>


      <p>N4JS has an IDE based on Eclipse. It comes with its own workspace, libraries and plugins. The IDE has a transpiler (i.e. a compiler that translates from one language to another) which validates N4JS code and then transforms it to JavaScript. The transpiler also performs imports from ECMAScript to N4JS. The benefit of type safety means that errors in code are noticed while editing in the IDE, allowing for problem-solving before code is ever deployed. The following screenshot shows the most important views of the IDE:</p>

      <div class="Image Image--fullWidth">
        <a href="fig/IDE.png"><img src= "fig/IDE.png"  ></a>
      </div>

      <p>Developers who have previous experience using Eclipse will be familiar with many common UI features such as the Editor, Project Outline, Project Explorer and Console views. The arrangement of views can be easily selected using the perspectives icons as highlighted in the upper-right of the window. </p>


      <h2 id="Installation">Installation</h2>


      <p>You can download the N4JS IDE as a standalone product or install the N4JS features to your existing Eclipse installation. Links to the latest nightly build and the update site are provided on the <a href="https://numberfour.github.io/n4js/">N4JS project page</a>.</p>


      <h3>Prerequisites</h3>

      <h4>N4JS IDE</h4>

      <p>In order to run the N4JS IDE, Java 8 is required. Installer packages can be downloaded from <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Oracle's Java pages</a>.</p>

      <p>Tip for Mac OS X users: Always install the JDK and not the JRE, as the latter is installed and only to be used in web browsers and not available for applications.</p>

      <p>When installing the N4JS features into an existing Eclipse installation, make sure that Xtext 2.9.1 is available. In general N4JS is based on the Eclipse Mars release.</p>

      <h4>Node.js</h4>

      <p>In order to run or test code from the IDE, <a href="https://nodejs.org/en/">Node.js version 5</a> (or later) is required.</p>


      <!-- ======================================================================= -->
      <h2 id="Overview">Overview: Using N4JS to Implement a Node.js Application</h2>

      <p>In order to illustrate some of the features of N4JS, we shall look at building a Node.js-based server of a Task Manager which serves as a reminder or to-do list application. As we build this basic example, we shall add improvements step-by-step, introducing new features with each increment in order to demonstrate some of the strengths of the language and IDE through a simple practical model. </p>

      <p>Before we dive in and start creating our example, it's worth briefly describing the architecture of our application in order to have a considered approach to the concept.  In this particular example, we can think of a multitiered client-server structure. The idea here is that when we have the application separated, each tier can be reused for different purposes.</p>

      <div class="Image">
        <a href="fig/architecture.svg"><img src= "fig/architecture.svg"  ></a>
      </div>

      <p>We will start with modeling and implementing the domain model before implementing a first version of the storage tier which will enable our first tests. The controller is then built using a test-driven approach. We later improve the storage tier using a real database before adding a REST API with express and, finally, a simple Web UI.</p>

      <h3 id="Newproject">Creating a new N4JS Project</h3>

      <p>Let's begin by creating a new N4JS Project that contains our whole application. In case of larger applications, we might want to create projects for each component (or tier) of the application. In order to keep this example small, we will use only one project.</p>

      <p>The "New N4JS Project" wizard can be accessed at <strong>File | New | N4JS Project </strong> (Or using the keyboard shortcuts <kbd>Command+option+N</kbd> for Mac, <kbd>Alt+Shift+N</kbd> on Windows)</p>

      <div class="Image">
        <a href="fig/newProjectWizard.png"><img src= "fig/newProjectWizard.png" ></a>
      </div>

      <p>When we select <strong>Finish</strong>, a new project folder is created with the following content:</p>

      <ul>
        <li>folder <strong>src</strong>: contains the .n4js source files for the project</li>
        <li>folder <strong>src-gen</strong>: contains the transpiled JavaScript that is generated after compiling n4js files. The IDE automatically transpiles n4js files on save</li>
        <li><strong>manifest.n4mf</strong>: project description file, containing description of dependencies</li>
      </ul>

      <h2 id="DomainModel">The Domain Model</h2>

      <p>Before we start implementing the domain model, we shall take a look at a UML diagram of it:</p>

      <div class="Image">
        <a href="fig/domainmodel.svg"><img src="fig/domainmodel.svg" ></a>
      </div>

      <p>The UML diagram illustrates how the entities of our domain model are related and which features the classes of the model will have.</p>
      <p>We will begin by defining Task which is extended by Appointment and Todo.</p>

      <h3>Creating new classes and modules</h3>
      <p>In our new N4JS project, we can begin creating our entities. The easiest way to complete this is to utilize the "New N4JS Class" wizard.</p>

      <p>The New N4JS Class wizard can be accessed at <strong>File | New | N4JS Class </strong></p>

      <div class="Image">
        <a href="fig/newClassWizard.png"><img src="fig/newClassWizard.png"></a>
      </div>

      <p>N4JS supports modules introduced by ECMAScript 2015. A module contains functions, classes and other declarations and code. The declared elements can be exported and imported by other modules. We will use a single module for all classes of our domain model. In larger projects, one might follow the Java convention to create a single file per class. </p>

      <p>The module specifier is the full path name of the module file, relative to the source folder. We use Unix-like path separators, that is forward slashes "/". In the Class Wizard (and later in import statements) we will omit the file extension.</p>

      <p>In the above figure, we are creating a new class named Task which will be saved in the module <strong>model</strong> in the project source folder. </p>

      <h3 id="Task">Implement the entity classes</h3>

      <p>The class wizard has already created a file and the empty class "Task". We will manually enhance this class as follows:</p>

      <div class="ExampleExplanation">
        <div class="ExampleExplanation-text">
          <p>In the first line of code, we have defined an <strong>abstract class</strong> named Task. Classes in N4JS are similar to classes in ECMAScript 2015 or Java. The concept of an abstract class is borrowed from Java. That means in our model we cannot have a direct instance of Task, but we may have subclasses of Task. </p>
        </div>

        <div class="ExampleExplanation-code">
<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">          export abstract class Task {  
            public id: string?;
            public label: string?;  
          }
</pre></div>
        </div>
      </div>

      <p>We are populating the class with fields which are simple data fields of the class. This is also borrowed from Java. The transpiler will move the field (with possible initializers) into the constructor. The two data fields of Task are id and label which we have annotated with types. The N4JS transpiler will later remove these type annotations.</p>

      <p>The type annotations declare the type of the data field. The type checker will issue errors if we later assign values of non-compatible type to the variables. The question mark "?" is a type modifier declaring the value as optional. That means that a new Task may or may not have values assigned for their id and label.</p>

      <p>N4JS also provides the concept of access modifiers similar to Java with the modifiers "public", "protected", "project" and "private". Access modifiers constrain the visibility of elements, that is, they restrict from where an element can be accessed. "Public" means that the element can be accessed from everyhwere, "protected" that the element may only be accessed from subclasses, "project" only from within the project and "private" only from within the same module. The default visibility is "project".</p>

      <p>We now manually add two classes to the same file:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      /** An appointment. */
      export class Appointment extends Task {  
        public time: Date?;  
        public place: string;  
      }

      export class Todo extends Task {  
        public dueDate: Date?;   
        public done = false;  
      }  
</pre><div class="Example-caption">model.n4js</div></div>

      <p>The class Appointment is a <em>subclass</em> of Task. This is achieved by using the keyword "extends" and demonstrates <strong>inheritance</strong>. N4JS supports single class inheritance similar to ECMAScript 2015 or Java. The subclass Appointment will inherit the members <em>id</em> and <em>label</em> with types from Task. </p>

      <p>We add the members <em>time</em> and <em>place</em> with <strong>type annotations</strong>. The type annotations of the members in Appointment are more strict then before, since the optional modifier (denoted by the question mark) is missing. We will see the effects of these different modifiers later on. </p>

      <p>Class Todo has a data field without type annotation but with an initializer. The N4JS type checker can infer the type of the initializer, in this case a boolean literal, and implicitly sets the type of the field to boolean.</p>

      <p>In all classes we have defined above, we are using the ECMAScript 2015 <code>export</code> keyword so that Appointment and Task can be imported and reused in other modules. As the project grows, the benefits of having individual, reusable <strong>modules</strong> become more and more useful in that they can be imported into other modules or even other projects.</p>

      <p>It's worth noting that Appointment is prefaced with a "JSDoc" annotation (a comment beginning with <code>/**</code> and closed with <code>*/</code>) which documents that it is a single Todo task. JSDoc comments are used to provide markup annotation of your code. The content of these comments is displayed when you hover over a reference to that element.</p>

      <h3>Add an Enumeration</h3>

      <p>We also want to add a priority field to the <code>Todo</code> class. We will modify the <code>Todo</code> class and add a new type <code>Priority</code> as follows:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      export class Todo extends Task {
        public dueDate: Date?;
        public priority = Priority.NORMAL;
        public done = false;
      }

      @StringBased // using string-based enum to simplify (de-)serialization
      export enum Priority {
        LOW, NORMAL, HIGH
      }
</pre><div class="Example-caption">model.n4js (cntd.)</div></div>

      <p>Enumerations allow us to  represent a fixed set of constants: <code>LOW</code>, <code>NORMAL</code> and <code>HIGH</code>. The reason we use an enumeration here is because we know all possible values for Priority at compile-time so we may limit it to these constants. N4JS provides two kinds of enumerations: "ordinaray" enumerations and "string-based" enumerations. The former will be translated to objects, enabling extended reflection (e.g., get the type of the enumeration, get all literals). The latter will be translated to strings. Actually, literals of string based enumerations are represented as plain string in the JavaScript output code. Due to that they offer less reflection capabilities.</p>


      <h2 id="Storage">The Storage Layer</h2>

      <p>Let's first have a look at the UML diagram describing out storage tier:</p>

      <div class="Image">
        <a href="fig/storage.svg"><img src="fig/storage.svg"></a>
      </div>

      <p>The storage tier is responsible for persisting our entities. We will create two different kinds of "persistence". We will start with a simple in-memory peristence, which can be used for testing. Later on, we will add a proper persistence layer using MongoDB.</p>

      <h3>Defining an Interface</h3>

      <p>We can create the storage module with the Class wizard (note: an interface wizard will be available soon. For the moment, either create an empty file with extension n4js or use the class wizard and manually change the file name). We call it "Storage.n4js", following Java's convention of naming the module similar to the contained class or interface. We will manually edit the file as follows:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import { Task } from "model"

      export public interface Storage {

        size(): int
        clear()

        getTasks(): Array&lt;Task&gt;
        storeTask(task: Task): string

        isEmpty(): boolean {
          return (this.size()) === 0;
        }
      }
</pre><div class="Example-caption">Storage.n4js</div></div>

      <p>The very first line of code displays ECMAScript 2015's import statement. It is a so-called "named import": We import the element "Task", in our case a class, from the module with the specifier "model". </p>

      <p>This time, we do not define a class but an interface "Storage". N4JS supports <strong>interfaces</strong> which operate similar to those in Java 8. Interfaces are similar to classes, but they cannot be instantiated. In N4JS it is however possible to use the "instanceof" operator with interfaces. Usually interfaces contain abstract methods, but they can contain data fields, getters and setters as well. Similar to Java 8, interface methods can provide a default implementation. We use this here for the method isEmpty. Classes implementing the interface can either rely on this default implementation or provide a more efficient one. As in Java, a class can implement multiple interfaces, and also interfaces can extend multiple interfaces.</p>

      <h3>Implement the Interface</h3>

      <p>Since we cannot instantiate an interface, we need a class implementing the interface. We will create a new module for a class called "StorageInMemory.n4js". This module will simply keep all entities in memory. If you copy-paste the following code snippet in your IDE, you will see a few errors. Do not fret, it is expected and we will deal with them shortly.</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import { Storage } from "Storage"
      import { Task } from "model"

      export class StorageInMemory implements Storage {

        private lowestUnusedId = 1;
        @Final
        private tasks = new Map&lt;string,Task&gt;(); // &lt;-- IDE will show error, here!

        @Override
        public size(): int {
          return this.tasks.size;
        }

        @Override
        public storeTask(task: Task): string {
          let id = 'id' + this.lowestUnusedId++;
          this.tasks.set(id, task);
          task.id = id;
          return id;
        }

        @Override
        public clear() {
          this.lowestUnusedId = 1;
          this.tasks.clear();
        }

        @Override
        public getTasks(): Array&lt;Task&gt; {
          return Array.from(this.tasks.values());
        }
      }
</pre><div class="Example-caption">StorageInMemory.n4js</div></div>

      <p>Above code will raise a compile error, because type <code>Map</code> is not available in ECMAScript Version 5. We'll have to tell N4JS that our example is intended to run as ECMAScript 2015. Before doing this, in the following section, let's first look at the other parts of the above class declaration in some more detail.</p>

      <p>We use the keyword "implements", known from Java to define that this class implements the interface. We have to provide specific implementation of the methods of the Storage interface by using the <code>@Override</code> annotation to define <code>size</code>, <code>clear</code>, <code>getTasks</code> and <code>storeTasks</code> (not all methods are shown here). This annotation is similar to the annotation used in Java. It ensures that whenever a method in the interface is changed, the type checker can issue a warning. This can be a lifesaver when larger projects are to be maintained over time or across several development teams.</p>

      <p>We use a data field "tasks" to store all the tasks in a map. The type Map stems from ECMAScript 2015. It is a generic type similar to Array, which the observant reader may have already seen in the Storage interface. N4JS support for generic types and methods is similar to Java 8.</p>

      <h3>Edit the Manifest</h3>

      <p>By default, N4JS provides all the types known by ECMAScript 5. In order to use elements (types, functions or variables) defined by a newer JavaScript version, we have to add a corresponding runtime library as project dependency to the manifest. This has no direct effect on the compiled code, it simply tells the type checker to assume that certain types of a newer JavaScript version will be available at runtime (provided by the JavaScript engine the code is intended for).</p>

      <p>Such meta information about an N4JS project is kept in a special, so-called <em>manifest file</em>. So, we need to open the file "manifest.n4mf" and edit a dependency. The default manifest files created by the New Project wizard looks like that:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      ArtifactId: n4js.example.tasks
      VendorId: eu.numberfour
      ProjectName: "n4js.example.tasks"
      VendorName: "NumberFour AG"
      ProjectType: library
      ProjectVersion: 0.0.1
      Output: "src-gen"
      Sources {
        source {
          "src"
        }
      }
</pre><div class="Example-caption">manifest.n4mf</div></div>

      <p>We need to add the following section at the end. Note that the manifest editor supports content assist similar to the N4JS editor.</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      RequiredRuntimeLibraries {
        n4js-runtime-es2015
      }
</pre></div>

      <p>This will add all additionally defined types of ECMAScript 2015. It will also add new methods to types already defined in ECMAScript 5.</p>

      <h3>Running a Module</h3>

      <p>Having created the first version of our domain model and storage tier, we are ready to try it out. For that, we create a module "Runner.n4js" with the following code:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import { StorageInMemory } from "StorageInMemory"
      import { Todo } from "model"

      let sim = new StorageInMemory();
      let todo = new Todo();
      todo.done = false;
      todo.dueDate = new Date();
      todo.label = "Test TODO";
      sim.storeTask(todo);

      console.log(sim.getTasks());
</pre></div>

      <p>We then launch this module with Node.js. The easiest way to do that is with the context menu (accessed by right-clicking in the editor) and selecting "Launch in Node.js". as shown in the following screenshot:</p>

      <div class="Image">
        <a href="fig/firstLaunch.png"><img src="fig/firstLaunch.png"></a>
      </div>

      <p>This will run the module currently opened in the editor. The output will be printed to the console view, for example</p>

      <div class="Image">
        <a href="fig/firstLaunchConsole.png"><img src="fig/firstLaunchConsole.png"></a>
      </div>

      <h3>Extend Entities with Spec-Constructor</h3>

      <p>When we look at the runner code, creating a new task is quite annoying: It has to be created with a new expression, and then every data field has to be set separately. To simplify this, we add a constructor to our base entity class Task as follows:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      export abstract class Task {

        // ...

        constructor(@Spec spec: ~i~this?) {  
          // code for initialization will be generated due to @Spec annotation  
        }  
      }  
      …
</pre><div class="Example-caption">model.n4js (cntd.)</div></div>

      <p>The concept of constructors is taken from ECMAScript 2015. However, the parameter is very special to N4JS. We briefly describe the type expression <code>~i~this?</code> used here. We already know <code>?</code> to be the optional modifier. If a parameter of a function is marked as optional, N4JS allows for omitting it in the call (or in case of constructors in the new expression). <code>this</code> is a known keyword in ECMAScript, it usually refers to the receiver of a property or, in case of classes, method call. But here we use it as a type expression, referring to the type of the <code>this</code> keyword. This is usually the class in which the method or constructor is defined. That is, in case of Task it will be <code>Task</code>. However, we have two subclasses of <code>Task</code>. We do not define a new constructor in these classes, instead we let these classes inherit <code>this</code> constructor. In case of <code>Todo</code>, the <code>this</code> type will become <code>Todo</code> and in case of <code>Appointment</code>, <code>Appointment</code>. Simply referring to the <code>this</code> type wouldn't make any sense in the constructor, since we would need a first instance in order to create another one &mdash; but how could we create the first one? The solution comes with the <code>~i~</code> prefix.</p>

      <p>As discussed in the feature sheet, N4JS supports nominal and structural typing. Structural typing is activated in N4JS with the tilde <code>~</code>. Two structural types are compatible, if they provide the same properties, or in case of classes, public members. In the constructor, we only need to set the fields. In N4JS, we can use <code>~~</code> to refer to the so-called "field structural type". Two field structural types are compatible, if they provide the same fields &mdash; methods are ignored in these cases. Actually, optional fields are also ignored. This explains why we marked some of the fields with the optional modifier. Note that fields with an initializer are also treated as optional (since the initializer provides a default value). Actually, N4JS can do even more. There are several modifiers to further filter the properties or members to be considered: <code>~r~</code> only considers getters or data fields, <code>~w~</code> only setters and data fields. <code>~i~</code>  is used for initializer parameters: For every setter or (non-optional) data field in the type, the <code>~i~</code> -type needs to provide at least a getter (or a readable data field). Optional fields are also treated as optional in the field structural types.</p>

      <p>For the concrete class <code>Todo</code>, the <code>~i~</code> -type is not required to contain any property since all its fields are either optional or have an initializer. It contains the optional fields <code>id</code>, <code>label</code>, <code>dueDate</code> and <code>done</code>. <code>~i~Appointment</code> contains the required properties <code>time</code> and <code>place</code>, and the optional fields <code>id</code> and <code>label</code>.</p>

      <p>In most cases, we need this information in the constructor to set the fields accordingly. For Task we would write:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      constructor(spec: ~i~this?) {
        this.id = spec.id;
        this.label = spec.label;
      }
</pre></div>

      <p>In order to simplify the code, the annotation <code>@Spec</code> tells the transpiler to add exactly this code automatically. Even better: Since <code>Appointment</code> and <code>Todo</code> inherit the constructor, the transpiler will add constructor code in these classes to set the additional fields also. That is, with this single constructor, the <code>@Spec</code> annotation and the <code>~i~this</code> type expression, we have solved the problem of initialization for all our entity classes with a single stroke!</p>

      <p>Using this <code>@Spec</code> constructor would then look similar to this:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      let todo = new Todo({dueDate: new Date(), label: "Test TODO"});
      sim.storeTask(todo);
</pre></div>

      <h3>Short summary</h3>

      <p>The main concepts demonstrated so far by our example are:</p>

      <ul>
        <li><strong>Modules</strong> with import and export</li>
        <li><strong>Classes</strong> with inheritance and constructors</li>
        <li><strong>Interfaces</strong> with default methods</li>
        <li><strong>Enumeration</strong></li>
        <li>Special strategies for structural types</li>
        <li><strong>Manifest.n4mf</strong> file and runtime library dependencies</li>
      </ul>

      <p>We can now proceed to implement a Task Manager.</p>

      <h2 id="TaskManager">Creating a Task Manager</h2>

      <p>We will now create the controller tier. This tier uses the entity and storage classes to provide functionality that is actually useful for the user of the application.</p>

      <p>Since we eventually want to implement a REST API (and use a real data base), we need to introduce asynchronous functions. So before we actually implement any controller class, we have to adjust our storage tier to support asynchronous functions.</p>

      <h3>Make the Storage Asynchronous</h3>

      <p>If we would like to use a real data base, all calls to the data base will be asynchronous. Asynchronous programming is a typical task in ECMAScript and there are several solutions to do this.</p>

      <p>ECMAScript 2015 introduced a new class Promise which is supposed to be used with in these cases. Its methods accept callback functions which are called once the asynchronous event has been triggered. Since these callback functions tend to call other asynchronous functions, ECMAScript programmers easily end up in the so called 'callback hell'. There is a proposal for upcoming ECMAScript versions to use special constructs in the language to get rid of this callback hell. The idea is to mark asynchronous functions as "async" and, when these functions are called, the program can "await" the result. This async/await feature is already supported by several JavaScript frameworks and it is also built-in to N4JS including validation.</p>

      <p>First we have to change the Storage interface and mark all methods which are supposed to be asynchronous as "async":</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import { Task } from "model"

      export public interface Storage {

        async size(): int
        async clear()

        async getTasks(): Array&lt;Task&gt;
        async storeTask(task: Task): string

        async isEmpty(): boolean {
          return (await this.size()) === 0;
        }
      }
</pre><div class="Example-caption">Storage.n4js (cntd.)</div></div>

      <p>Note than after adding "async" to the size method and without adding the "await" keyword, you will get a warning in method isEmpty similar to that:</p>

      <div class="Image">
        <a href="fig/awaitWarning.png"><img src="fig/awaitWarning.png"></a>
      </div>

      <p>You will also get a lot of other errors in other files:</p>

      <div class="Image">
        <a href="fig/asyncErrors.png"><img src="fig/asyncErrors.png"></a>
      </div>

      <p>Without an async/await and type aware IDE you probably would have missed one or the other of these errors. We can easily fix that by simply adding "async" to all the indicated methods.</p>

      <p>If you still have the runner module, you probably will get a warning there as well. If you ignore that warning and run it again, you will get the following</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      Promise { &lt;pending&gt; }
</pre></div>

      <p>instead of the expected output. We are not going to fix this problem now as we will introduce a better way of testing the code after the next step.</p>

      <h3>Create TaskManager</h3>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import { Todo } from "model"
      import { Task } from "model"
      import { Storage } from "Storage"
      import { StorageInMemory } from "StorageInMemory"

      export public class TaskManager {

        private storage: Storage = new StorageInMemory();

        public async getTasks(): Array&lt;Task&gt; {
          return await this.storage.getTasks();
        }

        public async createTodo(label: string): string {
          let newTodo = new Todo({label: label});
          let newId = await this.storage.storeTask(newTodo);
          return newId;
        }
      }
</pre><div class="Example-caption">TaskManager.n4js</div></div>

      <p>This class does not reveal any new concepts, but how do we test it? For that, we are going to use the N4JS test framework.</p>

      <p>By utilizing the built-in test suite, classes and modules will not become polluted with superfluous test-code. In addition, it is possible to overcome some access modifiers restrictions so there's no need to restructure or rewrite your code specifically to run tests.</p>

      <p>Since we use a tier architecture, it is quite easy to add a test: We simply replace one tier with appropriate tests:</p>

      <div class="Image">
        <a href="fig/controllerTest.svg"><img src="fig/controllerTest.svg"></a>
      </div>


      <h2 id="Testing">Testing</h2>

      <p>Since we do not want to mix up the application with the tests, we create a new project. We use the new project wizard</p>

      <div class="Image">
        <a href="fig/createTestProject.png"><img src="fig/createTestProject.png"></a>
      </div>

      <p>We adjust the "manifest.n4mf" accordingly:</p>

      <ul>
        <li>Define which project we test in the "TestedProjects" section.</li>
        <li>Change the "source" folder to "test" folder. This way the IDE knows where to look for tests later on.</li>
        <li>Add project dependencies to the built-in test framework "mangelhaft", which also provides a nice collection of assert methods.</li>
      </ul>

      <p>After adding these changes, the manifest of the test project will look as follows:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      …
      TestedProjects {
        n4js.example.tasks
      }
      Output: "src-gen"
      Sources {
        test {
          "src"
        }
      }
      ProjectDependencies {
        eu.numberfour.mangelhaft,
        eu.numberfour.mangelhaft.assert
      }
</pre><div class="Example-caption">manifest.n4mf (in project n4js.example.tasks.tests)</div></div>

      <p>We can now write our first test. Again, we use the class wizard to create a module "TaskManagerTest" containing a class with the same name. The first test should look like that:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import { TaskManager } from "TaskManager"
      import { Assert } from "n4/mangel/assert/Assert"

      export public class TaskManagerTest {

        mgr: TaskManager = new TaskManager();

        @Test
        async testCreateTodo() {
          await this.mgr.createTodo("test todo");
          Assert.equal("test todo", (await this.mgr.getTasks())[0].label);
        }
      }
</pre><div class="Example-caption">TaskManagerTest.n4js</div></div>

      <p>Mangelhaft is an xUnit-like test framework. For the sake of simplicity, N4JS uses the same annotations as the popular Java test framework JUnit. In our case, we have a single test method which needs to be annotated with <code>@Test</code>. </p>

      <p>Since we are testing asynchronous code, the test method needs to be asynchronous as well and we need to "await" the results of the methods we call. Mangelhaft supports asynchronous code so we do not have to bother about that any further. This is the nice thing about using <code>async</code>/<code>await</code> and N4JS: asynchronous programming becomes as simple as synchronous programming!</p>

      <p>We can run the test via the IDE. This works similar to launching the code with Node.js by simply using the context menu. The IDE will detect a test and it will automatically add the correct menu entry to the context menu:</p>

      <div class="Image">
        <a href="fig/testInNodejs.png"><img src="fig/testInNodejs.png"></a>
      </div>

      <p>This will run the test and the test view will show the result of the first test:</p>


      <div class="Image">
        <a href="fig/firstTestResults.png"><img src="fig/firstTestResults.png"></a>
      </div>


      <h2 id="MongoDB">Storage using MongoDB</h2>

      <p>Instead of "storing" the entities in memory, we want to use a real database. In this example, we are going to use <a href="https://www.mongodb.com/">MongoDB</a>. To follow along this section on your own computer, you must have MongoDB installed and start a data base server instance via the command line as follows:</p>

      <pre>
      mongod --dbpath /db
      </pre>

      <p>In order to use MongoDB from N4JS, we need the appropriate npm package which allows MongoDB access from ECMAScript. Adding this npm and making it available in N4JS is as simple as adding any project dependency. We have to open the manifest editor (of the tasks project) and add the following project dependency:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      ProjectDependencies {
        mongodb
      }
</pre></div>

      <div class="Image">
        <a href="fig/quickfixNPMinstall.png"><img src="fig/quickfixNPMinstall.png"></a>
      </div>

      <p>The quick-fix will automatically download all required npm packages, that is mongodb and all its dependencies. We can now use mongodb from our N4JS code.</p>

      <p>To let N4JS know about the types a particular npm package provides, an N4JS definition file with extension <code>.n4jsd</code> is required (the same applies if you use a plain JavaScript file from N4JS). For some npm packages, definition files are provided on <a href="https://github.com/NumberFour/n4jsd">github.com/NumberFour/n4jsd</a>.</p>

      <p>Let's assume, for a moment, there were no <code>.n4jsd</code> file available for MongoDB. Then we import MongoDB using a so-called dynamic import, as follows:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import * as mongodb+ from "mongodb"

      mongodb.MongoClient.connect('mongodb://localhost:27017/tasks', function (err: any+, db: any+) {
        if (!err) {
          // ... use data base ...
          db.close();
        }
      });
</pre></div>

      <p>However, since we do have an <code>.n4jsd</code> file available, we can import types such as <code>MongoDB</code>, <code>Collection</code>, or <code>ObjectID</code> provided by MongoDB using an ordinary ECMAScript2015 named import, just as if we were importing from an N4JS module:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import { Storage } from "Storage";
      import { Task, Appointment, Todo } from "model";
      import { Collection, Db, MongoClient, ObjectID } from "mongodb";

      /**
       * Persistence for task lists using a mongodb instance.
       */
      export class StorageMongoDB implements Storage {
        cachedDb: Db = null;

        private async getTasksCollection(): Collection {
          if (!this.cachedDb) {
              this.cachedDb = await MongoClient.connect('mongodb://localhost:27017/tasks');
          }
          return this.cachedDb.collection('tasks');
        }

        public async shutdown() {
          this.cachedDb.close(true);
          this.cachedDb = null;
        }
      }
</pre><div class="Example-caption">StorageMongoDB.n4js</div></div>

      <p>In the above section of code, we are implementing StorageMongoDB from the Storage interface and then calling some of the standard MongoDB collection methods.</p>

      <p>The next step is to retrieve the information about our Tasks and to store them in our MongoDB database. In the storeTask method, we are then retrieving the inserted item id's from MongoDB and returning them as a <code>task.id</code>.</p>

      <p><em>(Note the use of the <code>=&gt;</code> arrow function, derived from ES6. Arrow functions have implicit lexical binding and are less verbose than traditional function expressions)</em></p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      export class StorageMongoDB implements Storage {

        // ...

        @Override
        public async size(): int {
          let coll = await this.getTasksCollection();
          return await coll.count({});
        }

        @Override
        public async clear() {
          let coll = await this.getTasksCollection();
          await coll.deleteMany({});
        }

        @Override
        public async getTasks(): Array&lt;Task&gt; {
          let coll = await this.getTasksCollection();
          let resultRaw = await coll.find({}).toArray();
          let result = resultRaw.map((data): Task =&gt; fromData(data));
          return result;
        }

        @Override
        public async storeTask(task: Task): string {
          let coll = await this.getTasksCollection();
          let result = await coll.insertOne(toData(task));
          if (result.insertedCount === 1) {
            task.id = result.insertedId.toHexString();
            return task.id;
          }
          throw new Error("insert document failed");
        }
      }
</pre><div class="Example-caption">StorageMongoDB.n4js (cntd.)</div></div>

      <p>Above code uses two helper functions, <code>toData()</code> and <code>fromData()</code>. Those illustrate two techniques available in N4JS: reflection and so-called <code>@Spec</code> constructors, respectively. Reflection is known from many languages and allows for retrieving information of a type and its members at runtime. It is used in <code>fromData()</code> as follows:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      function toData(task: Task): ~~Task {
        let metaClass = N4Type.of(task),
            data: any+ = {};
        // note: would have to set data._id, here, if we
        // wanted support for updating existing tasks
        data._type = metaClass.name;
        let taskAsObject: Object = task; // up-cast to object to allow index access
        for (let field of metaClass.dataFields(true,true)) {
          data[field.name] = taskAsObject[field.name];
        }
        return data;
      }
</pre><div class="Example-caption">StorageMongoDB.n4js (cntd.)</div></div>

      <p>Conversely, <code>@Spec</code> constructors are special constructors that allow to create a new instance of a class and initialize it with values provided by a plain data object in properties that correspond to the type's fields.</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      function fromData(data: any+): Task {
        let ctor = typeToCtor.get(data._type as string);
        if (!ctor) {
          throw new Error('Unsupported type of data model entity: ' + data._type);
        }
        let task = new ctor(data);
        task.id = (data._id as ObjectID).toHexString();
        return task;
      }

      const typeToCtor = new Map&lt;string,constructor{Task}&gt;([
        ['Todo', Todo] as Iterable2&lt;string, constructor{Task}&gt;,
        ['Appointment', Appointment] as Iterable2&lt;string, constructor{Task}&gt;
      ]);
</pre><div class="Example-caption">StorageMongoDB.n4js (cntd.)</div></div>

      <p>By using the above two helper functions, we avoid sending our data model instances directly to the MongoDB driver. Note that the entire implementation is intended for illustration purposes and in a real-world systems many details would be handled differently, depending on the actual requirements.</p>


      <h2 id="DI">Dependency Injection</h2>

      <p>We now have two implementations of the interface Storage. For testing, the in-memory solution is adequate, but for the application we want to use the MongoDB solution of course. Since we are using the Storage in our TaskManager class, we would need to change the TaskManager depending on the storage solution. This is inconvenient and error prone. It would be much better if we could configure which storage class to use from outside the TaskManager at some central location. This is possible with dependency injection.</p>

      <p>To learn more about how dependency injection works, we have written an <a href="../features/dependency-injection.html">extended feature description</a> that describes the benefits of this technique. In short, N4JS provides built-in support for dependency injection using the same annotations as known from JSR-330/Google Guice. Instead of using initializers calling the constructor for certain fields, we just mark them with <code>@Inject</code>. We will do that with the storage field in the TaskManager class:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      export public class TaskManager {

        @Inject
        private storage: Storage;
        
        // ...
      }
</pre><div class="Example-caption">TaskManger.n4js (cntd.)</div></div>

      <p>Remark: After removing the constructor, the IDE will create a warning that one of the imports is unused. You can easily fix that by using the "Organize Import" feature, either from the context menu (or via <strong>Command+Shift+O</strong> on Mac OS, <strong>Ctrl+Shift+O</strong> on Windows).</p>

      <p>How does N4JS now create the instance of storage? For that, we need an injector. An injector is responsible for creating all variables annotated with <code>@Inject</code>. The injector is configured with a so-called "binder". The binder is more or less a translation table telling the injector which type it should use to create a concrete instance when a certain type is given. In our case, we need to tell the injector whether we want an instance of StorageInMemory or StorageMongoDB. We are going to adjust the test accordingly.</p>

      <p>For that, we first add a binder to the test module "TaskManagerTest.n4js":</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      @Binder
      @Bind(Storage,StorageInMemory)
      class InMemoryBinder {}
</pre><div class="Example-caption">TaskMangerTest.n4js (cntd.)</div></div>

      <p>The annotation <code>@Binder</code> marks the class InMemoryBinder to become a binder. For each mapping we need to add an annotation <code>@Bind</code>, which takes the requested type as the first argument and the actual type as the second one. We only actually need to define bindings for interfaces. If the requested type is a class and if no binding is defined for it, the injector will simply create an instance of that very type.</p>

      <p>The next step is to create an injector. Fortunately, we do not have to do that manually. The dependency injection framework of N4JS introduces the notion of dependency injection components (DIC). A DIC is associated with an injector; this is done by using the annotation <code>@GenerateInjector</code>. Additionally we need to tell the framework which configuration it should use for the injector, this is done via the annotation <code>@UseBinder</code>, which expects the type name of a binder class.</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      @GenerateInjector @UseBinder(InMemoryBinder)
      export public class TaskManagerTest {
        …
      }
</pre><div class="Example-caption">TaskMangerTest.n4js (cntd.)</div></div>

      <p>The IDE helps us in finding problems: since the TaskManager class uses injection to get the storage field, it needs to be injected itself. The IDE warns us in the TaskManagerTest class:</p>

      <div class="Image">
        <a href="fig/injectionWarning.png"><img src="fig/injectionWarning.png"></a>
      </div>

      <p>This is hard to find but easy to fix: We just have to replace the initalizer with an <code>@Inject</code> annotation.</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      …
      export public class TaskManagerTest {
        @Inject
        mgr: TaskManager;
      }
</pre><div class="Example-caption">TaskMangerTest.n4js (cntd.)</div></div>

      <p>With these little changes, we can now configure the storage solution from outside the TaskManager class. Running this test will behave as before but we have removed the hard-coded dependency from TaskManager to StorageInMemory.</p>


      <h2 id="WebUI">Web UI module</h2>

      <p>The final step in building functionality into our model is to create a simple web user interface using express as a dependency to create a web server. We will then pass our tasks from MongoDB into a small amount of HTML to read the results. We will create the web server using <a href="http://expressjs.com/">Express</a>.</p>

      <p>In order to use Express, we need the appropriate npm module. Adding this npm and making it available in N4JS is as simple as adding any project dependency, as already shown for MongoDB, above. We have to open the manifest editor (of the tasks project) and add the following project dependency (along with the existing dependencies):</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      ProjectDependencies {
        mongodb,
        express
      }
</pre><div class="Example-caption">manifest.n4mf (cntd.)</div></div>

      <p>The quickfix will automatically download all required npm packages, that is, express and all its dependencies. We can now use express in our N4JS code (for more details, esp. N4JS definition files, see above description on MongoDB).</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      //Creating a simple Web User Interface in HTML

      import { TaskManager } from "TaskManager"
      import {Application, Response } from "express";
      import express from "express";
      import { Todo } from "model"

      export class WebUI {

        private app: Application;

        @Inject
        private manager: TaskManager;

        public start() {

          this.app = express();

          this.app.get('/', async (req, res) =&gt; {
            let page = await this.renderHomePage();
            res.send(page);
          });
        }
      }
</pre><div class="Example-caption">WebUI.n4js</div></div>

      <p>Express is a web framework that provides (among other things) HTTP helpers for web routing. In the above example, we are importing the classes <code>Application</code> and <code>Response</code> from express and creating a home page that we can render some HTML to. Next we will add a method for creating new tasks:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">        public start() {

          // ... code shown above ...

          this.app.get("/create", async (req, res) =&gt; {
            let values = req.query as ~Object with {type: string, label: string};
            if (values &amp;&amp; values.type === 'Todo' &amp;&amp; values.label &amp;&amp; values.label.length &gt; 0) {
              await this.manager.createTodo(values.label);
            }
            redirect(res, '/');
          });
        }
</pre><div class="Example-caption">WebUI.n4js</div></div>

      <p>Have express listen on port 4000 at localhost:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">        public start() {

          // ... code shown above ...

          this.app.listen(4000, '0.0.0.0', 511, function() {
            console.log("HTML server listening on http://localhost:4000/");
          });
        }
</pre><div class="Example-caption">WebUI.n4js</div></div>

      <p>Finally, we add a helper method for rendering a simple HTML page so we can view our Todos and edit them: </p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      export class WebUI {

        // ... methods shown above ...

        protected async renderHomePage(): string {
          let tasks = await this.manager.getTasks();
          let todos = tasks.filter((task) =&gt; task instanceof Todo);
          return `
            &lt;html&gt;
            &lt;body&gt;
              Your to-do's:
              &lt;ul&gt;
                ${
                  tasks.length === 0 ? '&lt;li&gt;&lt;em&gt;none&lt;/em&gt;&lt;/li&gt;\n'
                  : tasks.map((task) =&gt;
                  '&lt;li&gt;'+task.label+' &lt;small&gt;(id: '+ task.id +')&lt;/small&gt;&lt;/li&gt;'
                  ).join('\n')
                }
              &lt;/ul&gt;
              &lt;hr/&gt;
              &lt;form action="/create" method="get"&gt;
                &lt;input type="hidden" name="type" value="Todo"&gt;
                Label: &lt;input type="text" name="label"&gt;&lt;br&gt;
                &lt;input type="submit" value="Create Todo"&gt;
              &lt;/form&gt;
              &lt;hr/&gt;
              &lt;a href="/clear"&gt;[Clear All]&lt;/a&gt;
            &lt;/body&gt;
            &lt;/html&gt;
            `;
        }
      }

      function redirect(res: Response, url: string) {
        res.header('Cache-Control', 'no-cache');
        res.redirect(301, url);
      }
</pre><div class="Example-caption">WebUI.n4js</div></div>

      <p>At this point, we have to launch our web server. For this purpose, we create a small launch script that configures the dependency injection (as shown in the section on dependency injection, above), creates an intance of class <code>WebUI</code>, and invokes method <code>start()</code>:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import { Storage } from "Storage";
      import { StorageMongoDB } from "StorageMongoDB";
      import { WebUI } from "WebUI";
      import { N4Injector } from "n4js/lang/N4Injector";

      @Binder
      @Bind(Storage, StorageMongoDB)
      class Binding { }

      @GenerateInjector
      @UseBinder(Binding)
      class Root { }

      N4Injector.of(Root).create(WebUI).start();
</pre><div class="Example-caption">launch.n4js</div></div>

      <p>You can now use the HTML interface by going to <a href="http://localhost:4000/">http://localhost:4000/</a>, allowing you to interact with all of the logic we have built so far in order to read Tasks, create new Tasks and clear the storage.</p>

      <p>All of the fundamental elements of our model are completed and we have a functioning Task Manager with a simple Web UI. </p>


<!--
      <h2>Testing Our Finished Model</h2>
      <div class="TODO">Revise this section</div>

      <p>We can use the annotation <code>@Before</code> to delegate the order in which certain tests take place. If we wanted to mark a method to be executed once before each test in a given test class, we use <code>@Before</code> test annotation. If we want a method to be executed once before all tests, such as clearing a database, we can use the keyword <code>@BeforeAll</code>.  </p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      import { Priority, Appointment, Todo } from "model";
      import { Storage } from "Storage";
      import { Assert } from "n4/mangel/assert/Assert";

      /**
      * Contains the actual test cases for testing implementations of Storage.
      * Subclasses will choose which concrete implementation to test.
      */
      export public abstract class AbstractStorageTest {

        /** A storage intended for testing. Created in #prepare() method. */
        private storage: Storage;

        protected abstract createStorage(): Storage;

        @BeforeAll
        async prepareStorage() {
          this.storage = this.createStorage();
        }

        @Before
        async clearStorage() {
          // make sure test storage is empty before each test starts
          await this.storage.clear();
        }

      }
</pre></div>

      <p>Using the test annotation <code>@BeforeAll</code>, we are creating the storage space a single time before running all of our tests. The next section with the annotation <code>@Before</code>, ensures that the storage we created is cleared before each test. After all tests are complete, we run a 'garbage collector' method telling MongoDB to <code>shutdown</code> which cleans up all database resources and terminates the process.</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      @Test
      async testStoreAppointment() {
        let s = this.storage;
        let appointment = new Appointment();

        Assert.equal(0, await s.size());
        let id = await s.storeTask(appointment);
        Assert.equal(1, await s.size());
        Assert.equal(id, appointment.id);
      }

      @Test
      async testGetTasks() {
        let s = this.storage;
        let todo = new Todo({
          label: 'test',
          priority: Priority.HIGH,
          dueDate: new Date(2016, 3, 13, 14, 30, 0)
        });

        await s.storeTask(todo);
        let restoredTasks = await s.getTasks();

        Assert.equal(1, restoredTasks.length);
        Assert.isTrue(restoredTasks[0] instanceof Todo);
        let restoredTodo = restoredTasks[0] as Todo;
        Assert.equal(todo.label, restoredTodo.label);
        Assert.equal(todo.priority, restoredTodo.priority);
        Assert.equal(todo.dueDate.getTime(), restoredTodo.dueDate.getTime());
      }
</pre></div>

      <p>Now that our AbstractStorageTest module is completed, we can create further test modules for other sections of our project:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      // Creating StorageInMemoryTest to extend AbstractStorageTest

      import { AbstractStorageTest } from "AbstractStorageTest"
      import { Storage } from "Storage"
      import { StorageInMemory } from "StorageInMemory"


      export public class StorageInMemoryTest extends AbstractStorageTest {

        @Override
        protected createStorage(): Storage {
          return new StorageInMemory();
        }
      }
</pre></div>

      <p>In this instance, we are importing AbstractStorageTest and overriding the <code>createStorage</code> method and adapting it for use in testing our StorageInMemory module.</p>

      <p>The same can be done to test our MongoDB module:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      //Creating StorageMongoDBTest to extend AbstractStorageTest

      import { AbstractStorageTest } from "AbstractStorageTest"
      import { Storage } from "Storage"
      import { StorageMongoDB } from "StorageMongoDB"


      export public class StorageMongoDBTest extends AbstractStorageTest {

        @Override
        protected createStorage(): Storage {
          return new StorageMongoDB();
        }
      }
</pre></div>

      <p>By importing our test module and using method overriding, we can adapt and reuse the same test module for a number of practical purposes, saving time and building an efficient testing system.</p>
-->


      <h2 id="ExportAsNPM">Export as npm</h2>

      <p>Finally, we can export our project as an npm package to integrate it into other Node.js projects or to launch from command line.</p>

      <ol>
      <li>You can export one or multiple projects by selecting them in the Project Explorer and opening the "Export ..." wizard by right-clicking on them. On the first page select "N4 Exports / N4JS npm Export". For the purpose of this example, only export project <code>n4js.example.tasks</code>.</li>
      <li>On the second page you have to choose a target folder to export to.<br>
        IMPORTANT: export to a folder outside your Eclipse workspace!</li>
      <li>By default, the exporter exports as a directory. Optionally, you can export as a versioned tarball by checking the option "Compress the contents of the file".</li>
      <li>The last page of the wizard shows a preview of the package.json file that will be created in the exported npm package, together with a comparison to an existing package.json file in your N4JS project, if present. You can place such a package.json file next to your manifest.n4mf file (optional), in case you need to define more <a href="https://docs.npmjs.com/files/package.json">specifics in the package.json</a>, that are not covered by the N4JS export wizard.</li>
      </ol>

      <div class="Image">
        <a href="fig/npmExport.png"><img src="fig/npmExport.png"></a>
      </div>


      <h2 id="RunWithNode">Run from command line with Node.js</h2>

      <p>Once you've exported your project, you can either publish it to <a href="https://www.npmjs.com/">npmjs.com</a> or install directly from your hard disk and call the launch module, for example</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      $ npm install -g n4js.example.tasks
      $ node -r n4js.example.tasks/launch
      HTML server listening on http://localhost:4000/
</pre></div>

      <p>In case you want to install dependencies and run it right away in the exported npm folder, you have to manually set up the <code>NODE_PATH</code> to the folder hosting the exported npms, otherwise node cannot resolve the project/npm IDs.</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      $ export NODE_PATH=`pwd`
      $ pushd n4js.example.tasks; npm install; popd
      n4js.example.tasks@0.0.1 /Users/me/prj/n4js.example.tasks
      ├─┬ express@4.13.4
      ...
      $ node n4js.example.tasks/launch.js
      HTML server listening on http://localhost:4000/
</pre></div>

      <p>So far we've been loading all code via node's <code>require()</code> function.
      In case you want to load your modules via <a href="https://github.com/systemjs/systemjs">SystemJS</a>,
      which has more support to resolve cyclic dependencies across modules, you could use a handy starter executable called <code>n4js</code>. The <code>n4js</code> starter is part of the <code>n4js-node</code> runtime environmentnpm (a default dependency of any exported npm) and is therefore already installed:</p>

<div class="Example"><pre name="code" class="n4js:nocontrols:nogutter">      $ export NODE_PATH=`pwd`
      $ cd n4js.example.tasks; npm install
      n4js.example.tasks@0.0.1 /Users/me/prj/n4js.example.tasks
      ├─┬ express@4.13.4
      ...
      $ ./node_modules/.bin/n4js n4js.example.tasks/launch
      HTML server listening on http://localhost:4000/
</pre></div>

    </article>
  </div>

  <footer class="Grid">
    <div class="Cell Cell--12-12">
      <a href="http://www.numberfour.eu" target="_blank">NumberFour AG</a> · <a href="https://twitter.com/n4jsdev" target="_blank">Twitter</a>

      <a href="../#getting-started" class="Link--action">Get the N4JS IDE now!</a>
    </div>
  </footer>

  
  <script> dp.SyntaxHighlighter.HighlightAll('code'); </script>

<!-- n4js-webpage build web.production (Sun Mar 13 2016 16:49:37 GMT+0100 (CET)) -->
</body>
</html>
